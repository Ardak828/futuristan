<script>
/* ========== STAR CONFIGURATION ========== */
const STAR_CONFIG = {
    COUNT: 1200,
    BASE_SIZE: 0.5,
    SIZE_ATTENUATION: true,
    BASE_COLOR_TINT: 0xffffff,
    GENERATION_RADIUS: 800,
    STAR_ORBIT_SPEED: 0.0005,
    STAR_MAX_DRIFT: 10
};

let starsMesh, starPositions, starInitialPositions;

/* ---------- Create circular texture for glowing stars ---------- */
function createStarTexture() {
    const size = 64;
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    const gradient = ctx.createRadialGradient(
        size / 2, size / 2, 0,
        size / 2, size / 2, size / 2
    );
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.4, 'rgba(255,255,255,0.6)');
    gradient.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    return new THREE.CanvasTexture(canvas);
}

/* ---------- Create the background starfield ---------- */
function createBackgroundStars() {
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(STAR_CONFIG.COUNT * 3);

    for (let i = 0; i < STAR_CONFIG.COUNT; i++) {
        const radius = STAR_CONFIG.GENERATION_RADIUS * Math.random();
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.acos(2 * Math.random() - 1);
        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.sin(phi) * Math.sin(theta);
        const z = radius * Math.cos(phi);
        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    const texture = createStarTexture();
    const material = new THREE.PointsMaterial({
        size: STAR_CONFIG.BASE_SIZE,
        color: STAR_CONFIG.BASE_COLOR_TINT,
        map: texture,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: STAR_CONFIG.SIZE_ATTENUATION,
        depthWrite: false
    });

    starsMesh = new THREE.Points(geometry, material);
    scene.add(starsMesh);

    starPositions = geometry.attributes.position;
    starInitialPositions = positions.slice();
}

/* ---------- Animate the starfield (subtle orbital drift) ---------- */
function animateStars(time) {
    if (!starsMesh || !starPositions) return;
    const positions = starPositions.array;
    for (let i = 0; i < STAR_CONFIG.COUNT; i++) {
        const baseIndex = i * 3;
        const angle = STAR_CONFIG.STAR_ORBIT_SPEED * time + i * 0.1;
        const baseX = starInitialPositions[baseIndex];
        const baseY = starInitialPositions[baseIndex + 1];
        const baseZ = starInitialPositions[baseIndex + 2];

        positions[baseIndex] = baseX + Math.sin(angle) * STAR_CONFIG.STAR_MAX_DRIFT;
        positions[baseIndex + 1] = baseY + Math.cos(angle * 0.7) * STAR_CONFIG.STAR_MAX_DRIFT;
        positions[baseIndex + 2] = baseZ + Math.sin(angle * 0.5) * STAR_CONFIG.STAR_MAX_DRIFT;
    }
    starPositions.needsUpdate = true;
}

/* ---------- INIT â€” add this call to your existing init() ---------- */
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.FogExp2(0x000000, 0.0006);

    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 2000);
    camera.position.set(0, 0, 200);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.domElement.style.touchAction = 'none';
    document.body.appendChild(renderer.domElement);
    canvasElement = renderer.domElement;

    controls = new THREE.OrbitControls(camera, canvasElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 50;
    controls.maxDistance = 600;

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dir = new THREE.DirectionalLight(0xffffff, 1.6);
    dir.position.set(10, 10, 10);
    scene.add(dir);

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    nodeGroup = new THREE.Group();
    lineGroup = new THREE.Group();
    scene.add(nodeGroup);
    scene.add(lineGroup);

    // ðŸŒŒ Add stars before other content
    createBackgroundStars();

    // Continue your existing setup...
    createGalaxyNetwork();
    createLabels();
    populateFilterMenu();

    window.addEventListener('resize', onWindowResize, false);
    animate();
}

/* ---------- Animate loop ---------- */
function animate(time = 0) {
    requestAnimationFrame(animate);

    // Update orbit controls
    controls.update();

    // ðŸŒ  Animate stars
    animateStars(time);

    // Update other objects
    renderer.render(scene, camera);
}
</script>
